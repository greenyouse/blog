<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>Composable Queries</title>
<!-- 2016-12-15 Thu 04:55 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="Ed Babcock (greenyouse)" />
<meta  name="description" content="Hacks, projects, and general butt-kicking with Ed (greenyouse)"
 />
<meta  name="keywords" content="Clojure, ClojureScript, greenyouse, LISP" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>
<meta name='viewport' content='width=device-width' initial-scale=1>
                     <link rel='shortcut icon' href='/img/favicon.ico' />
                     <link rel='stylesheet' href='/css/bootstrap.min.css' type='text/css'/>
                     <link rel='stylesheet' href='/css/blog.css' type='text/css'/>
                     <script type='text/javascript' src='MathJax/MathJax.js?config=TeX-AMS-MML_HTMLorMML'></script>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="preamble" class="status">
<nav class="navbar navbar-default">
    <div class="container-fluid">
      <div class="navbar-header">
        <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#main-navbar">
          <span class="sr-only">Toggle navigation</span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="/index.html">EDBABCOCK</a>
      </div>
      <div class="collapse navbar-collapse" id="main-navbar">
        <ul class="nav navbar-nav">
          <li><a href="/about.html">About</a></li>
          <li><a href="categories.html">Categories</a></li>

        </ul>
      </div>
    </div>
  </nav>
</div>
<div id="content">
<h1 class="title">Composable Queries</h1>
<div class="container-fluid"><div class="row"><div id="post" class="col-md-6 col-md-offset-3 col-xs-10 col-xs-offset-1 col-sm-8 col-sm-offset-2 col-lg-4 col-lg-offset-4">
<link rel='stylesheet' href='/css/post.css' type='text/css'/>
<br>


<p>
This post is going to be a little bit experimental. I'm going to try
some speculative programming to build a library while I write this
post. I'll start by proposing an abstraction and then step through how
to create the parts, in piecemeal. As we go along, I'll supply reasoning
for my design choices.
</p>

<blockquote>
<p>
"Composition feels like function husbandry. You, breeder of functions,
select two with traits you'd like to combine and mash them together to
spawn a brand new one."
</p>

<p>
â€” DrBoolean, <a href="https://drboolean.gitbooks.io/mostly-adequate-guide/content/ch5.html#functional-husbandry">Mostly Adequate Guide, Ch.5</a>
</p>
</blockquote>

<br>

<p>
Over the last year or so, I've wanted to build a library for composing
SQL and Elasticsearch queries. I'm more of a generalist web developer
than a DBA, but I have worked with both SQL and ES in the past. One of
the things that I've found is that functional programming usefulness
doesn't need to stop at the database level, it can work for databases
too! In this post, I'll try to show some of the benefits of composable
queries and how generic data transformations can enhance them. This will
focus on SQL but the same pattern applies to ES as well.
</p>

<p>
Within the Clojure community, there seem to be three major approaches to
interacting with SQL:
</p>

<ol class="org-ol">
<li>Raw SQL
</li>
<li>Use Clojure functions as a DSL
</li>
<li>Use Clojure's data structures as a DSL
</li>
</ol>

<p>
Taking each of these tools as-is, they will be set up as static queries
against a database. Queries will most likely have their parameters
passed in to perform the query. That could look something like this:
</p>

<div class="org-src-container">

<pre class="src src-sql"><span style="color: #FBDE2D;">SELECT</span> *
<span style="color: #FBDE2D;">FROM</span> users
<span style="color: #FBDE2D;">WHERE</span> age &gt; min_age
</pre>
</div>

<div class="org-src-container">

<pre class="src src-clojure">(<span style="color: #FBDE2D;">def</span> <span style="color: #D8FA3C;">age_query</span>
  (read-query <span style="color: #61CE3C;">"age_query.sql"</span>))

(<span style="color: #FBDE2D;">defn</span> <span style="color: #ff1493;">do-age-query</span> [age]
  (age_query {<span style="color: #4c83ff;">:age</span> age
              <span style="color: #4c83ff;">:min_age</span> 18}))
</pre>
</div>

<p>
The query is wrapped in a function so the program can pass params and
interact with it. It's also somewhat limited though since it is a
static block of SQL that exists outside of the rest of the program. This
"SQL outside our program" style isn't a problem for a toy query like
this one. Larger queries that use this pattern, however, can be a huge
pain to maintain.
</p>

<p>
The benefit of a function or data structure DSL approach is that we can store
snippets as variables in our program and compose them together. When
choosing between the two, the function DSL will be more difficult to compose
since it's not native Clojure. With native data structures, we could
make our query a Clojure map and merge maps together to build larger
structures.
</p>

<p>
Here's an example of just that with a data-oriented DSL:
</p>

<div class="org-src-container">

<pre class="src src-clojure">(<span style="color: #FBDE2D;">def</span> <span style="color: #D8FA3C;">age-query</span>
  {<span style="color: #4c83ff;">:select</span> [<span style="color: #4c83ff;">:*</span>]
   <span style="color: #4c83ff;">:from</span> [<span style="color: #4c83ff;">:users</span>]
   <span style="color: #4c83ff;">:where</span> [<span style="color: #4c83ff;">:&gt;</span> <span style="color: #4c83ff;">:age</span> <span style="color: #4c83ff;">:min_age</span>]})

(<span style="color: #FBDE2D;">def</span> <span style="color: #D8FA3C;">location-query</span>
  {<span style="color: #4c83ff;">:select</span> [<span style="color: #4c83ff;">:*</span>]
   <span style="color: #4c83ff;">:from</span> [<span style="color: #4c83ff;">:users</span>]
   <span style="color: #4c83ff;">:where</span> [<span style="color: #4c83ff;">:=</span> <span style="color: #4c83ff;">:location</span> <span style="color: #4c83ff;">:target_location</span>]})

(<span style="color: #FF6400;">merge</span> age-query location-query)
<span style="color: #8B8989; font-style: italic;">;;</span><span style="color: #8B8989; font-style: italic;">=&gt; {</span><span style="color: #4c83ff; font-style: italic;">:select</span><span style="color: #8B8989; font-style: italic;"> [</span><span style="color: #4c83ff; font-style: italic;">:*</span><span style="color: #8B8989; font-style: italic;">], </span><span style="color: #4c83ff; font-style: italic;">:from</span><span style="color: #8B8989; font-style: italic;"> [</span><span style="color: #4c83ff; font-style: italic;">:users</span><span style="color: #8B8989; font-style: italic;">], </span><span style="color: #4c83ff; font-style: italic;">:where</span><span style="color: #8B8989; font-style: italic;"> [</span><span style="color: #4c83ff; font-style: italic;">:=</span><span style="color: #8B8989; font-style: italic;"> </span><span style="color: #4c83ff; font-style: italic;">:location</span><span style="color: #8B8989; font-style: italic;"> </span><span style="color: #4c83ff; font-style: italic;">:target_location</span><span style="color: #8B8989; font-style: italic;">]}</span>
</pre>
</div>

<p>
Wait a sec, that didn't compose at all; it overrode "age-query" with
"location-query"! This example shows that we can't compose whole
queries, it's much better to compose smaller parts first and then build
up from there.
</p>

<p>
If we can focus on the subsections of our query, then I think we'll get
closer to our goal of composing. The only significant difference between
the subsections is the where clause. What if we pulled those parts out
and stored them in variables? With that, we could use a function for
building up the where part.
</p>

<p>
Here's pseudo code:
</p>

<div class="org-src-container">

<pre class="src src-clojure">(<span style="color: #FBDE2D;">def</span> <span style="color: #D8FA3C;">min-age</span>
  [<span style="color: #4c83ff;">:&gt;=</span> <span style="color: #4c83ff;">:age</span> <span style="color: #4c83ff;">:min_age</span>])

(<span style="color: #FBDE2D;">def</span> <span style="color: #D8FA3C;">match-location</span>
  [<span style="color: #4c83ff;">:=</span> <span style="color: #4c83ff;">:location</span> <span style="color: #4c83ff;">:target_location</span>])

(<span style="color: #FBDE2D;">def</span> <span style="color: #D8FA3C;">person-query</span>
  {<span style="color: #4c83ff;">:select</span> [<span style="color: #4c83ff;">:*</span>]
   <span style="color: #4c83ff;">:from</span> [<span style="color: #4c83ff;">:users</span>]
   <span style="color: #4c83ff;">:where</span> (<span style="color: #FBDE2D;">and</span> min-age
               match-location)})
</pre>
</div>

<p>
Now, the where clause will be translated and create the query we want.
</p>

<p>
By focusing on the subsections like this, we can share semantics across
our codebase. Multiple queries can be built up from a small group of
subqueries.
</p>

<p>
OK, let's go further into the where clause. What if we didn't know what
kind of data might be given to the queries? What if the queries were
missing <code>:min_age</code> or <code>:target_location</code> params?
</p>

<p>
Well, we know we want to find users. If there's no age or location
constraint we should be OK to just return all the users. We'll use
constraints if they're present. Otherwise, the query should still run
without them.
</p>

<p>
To get that flexibility we can have <a href="deepfns.html">transitives</a> that pull data out of
inputs, test them, and output subqueries.
</p>

<div class="org-src-container">

<pre class="src src-clojure">(<span style="color: #FF6400;">require</span> '[<span style="color: #D8FA3C;">deepfns.core</span> <span style="color: #4c83ff;">:as</span> df]
         '[<span style="color: #D8FA3C;">deepfns.transitive</span> <span style="color: #4c83ff;">:as</span> t])

<span style="color: #8B8989; font-style: italic;">;; </span><span style="color: #8B8989; font-style: italic;">term&gt; for SQL's boolean terms</span>
(<span style="color: #FBDE2D;">def</span> <span style="color: #D8FA3C;">min-age</span>
  (term&gt; <span style="color: #4c83ff;">:&gt;=</span> <span style="color: #4c83ff;">:age</span> <span style="color: #4c83ff;">:min_age</span>))

(<span style="color: #FBDE2D;">def</span> <span style="color: #D8FA3C;">match-location</span>
  (term&gt; <span style="color: #4c83ff;">:=</span> <span style="color: #4c83ff;">:location</span> <span style="color: #4c83ff;">:target_location</span>))

(<span style="color: #FBDE2D;">def</span> <span style="color: #D8FA3C;">person-query</span>
  (query&gt;
   {<span style="color: #4c83ff;">:select</span> [<span style="color: #4c83ff;">:*</span>]
    <span style="color: #4c83ff;">:from</span> [<span style="color: #4c83ff;">:users</span>]
    <span style="color: #4c83ff;">:where</span> (and&gt; min-age
                 match-location)}))
</pre>
</div>

<p>
Here's an example input and what the output would look like:
</p>

<div class="org-src-container">

<pre class="src src-clojure"><span style="color: #8B8989; font-style: italic;">;; </span><span style="color: #8B8989; font-style: italic;">both are present, use both constraints</span>
{<span style="color: #4c83ff;">:min_age</span> 18 <span style="color: #4c83ff;">:target_location</span> <span style="color: #61CE3C;">"Antartica"</span>}
<span style="color: #8B8989; font-style: italic;">;;</span><span style="color: #8B8989; font-style: italic;">=&gt; {</span><span style="color: #4c83ff; font-style: italic;">:select...</span><span style="color: #8B8989; font-style: italic;"> </span><span style="color: #4c83ff; font-style: italic;">:where</span><span style="color: #8B8989; font-style: italic;"> [</span><span style="color: #4c83ff; font-style: italic;">:and</span><span style="color: #8B8989; font-style: italic;"> [</span><span style="color: #4c83ff; font-style: italic;">:&gt;=</span><span style="color: #8B8989; font-style: italic;"> </span><span style="color: #4c83ff; font-style: italic;">:age</span><span style="color: #8B8989; font-style: italic;"> 18] [</span><span style="color: #4c83ff; font-style: italic;">:=</span><span style="color: #8B8989; font-style: italic;"> </span><span style="color: #4c83ff; font-style: italic;">:location</span><span style="color: #8B8989; font-style: italic;"> "Antarctica"]]}</span>

<span style="color: #8B8989; font-style: italic;">;; </span><span style="color: #8B8989; font-style: italic;">only one present, foobar is nonsense</span>
{<span style="color: #4c83ff;">:min_age</span> 18 <span style="color: #4c83ff;">:foobar</span> <span style="color: #61CE3C;">"Antarctica"</span>}
<span style="color: #8B8989; font-style: italic;">;;</span><span style="color: #8B8989; font-style: italic;">=&gt; {</span><span style="color: #4c83ff; font-style: italic;">:select...</span><span style="color: #8B8989; font-style: italic;"> </span><span style="color: #4c83ff; font-style: italic;">:where</span><span style="color: #8B8989; font-style: italic;"> [</span><span style="color: #4c83ff; font-style: italic;">:&gt;=</span><span style="color: #8B8989; font-style: italic;"> </span><span style="color: #4c83ff; font-style: italic;">:age</span><span style="color: #8B8989; font-style: italic;"> 18]}</span>

<span style="color: #8B8989; font-style: italic;">;; </span><span style="color: #8B8989; font-style: italic;">both of these fail their checks, don't even create a where condition</span>
{}
<span style="color: #8B8989; font-style: italic;">;;</span><span style="color: #8B8989; font-style: italic;">=&gt; {</span><span style="color: #4c83ff; font-style: italic;">:select</span><span style="color: #8B8989; font-style: italic;"> [</span><span style="color: #4c83ff; font-style: italic;">:*</span><span style="color: #8B8989; font-style: italic;">] </span><span style="color: #4c83ff; font-style: italic;">:from</span><span style="color: #8B8989; font-style: italic;"> [</span><span style="color: #4c83ff; font-style: italic;">:users</span><span style="color: #8B8989; font-style: italic;">]}</span>
</pre>
</div>

<p>
This example handles variable inputs and runs queries that are relevant
to the data we pass in. Given different inputs, it will run slightly
different queries.
</p>

<p>
We could also need to perform normalization on our inputs. Let's say the
locations we've been using in our examples need to have <a href="https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2">ISO 3166-1
alpha-2</a> codes for country names. To make it tricky, we'll also require
that our query handles an older API that took full country names too.
</p>

<p>
To deal with the variable input formats, there should be a country name
normalization function to handle new and old API inputs. The function
can be called from a subquery using a transitive.
</p>

<div class="org-src-container">

<pre class="src src-clojure">(<span style="color: #FF6400;">require</span> '[<span style="color: #D8FA3C;">clojure.string</span> <span style="color: #4c83ff;">:as</span> s])

(<span style="color: #FBDE2D;">def</span> <span style="color: #D8FA3C;">alpha2-codes</span>
  #{<span style="color: #61CE3C;">"AC"</span> <span style="color: #61CE3C;">"AD"</span> <span style="color: #61CE3C;">"ZW"</span>})

(<span style="color: #FBDE2D;">def</span> <span style="color: #D8FA3C;">country-mappings</span>
  {<span style="color: #61CE3C;">"ascension island"</span> <span style="color: #61CE3C;">"AC"</span>
   <span style="color: #61CE3C;">"andorra"</span> <span style="color: #61CE3C;">"AD"</span>
   <span style="color: #61CE3C;">"zimbabwe"</span> <span style="color: #61CE3C;">"ZW"</span>})

(<span style="color: #FBDE2D;">defn</span> <span style="color: #ff1493;">normalize-country</span> [country]
  (<span style="color: #FBDE2D;">if-not</span> (<span style="color: #FF6400;">nil?</span> (alpha2-codes country))
    country
    ((<span style="color: #FF6400;">comp</span> country-mappings <span style="color: #D8FA3C;">s</span><span style="color: #EDEDED; background-color: #000000;">/</span>lower-case) country)))

(<span style="color: #FBDE2D;">def</span> <span style="color: #D8FA3C;">min-age</span>
  (clause&gt; <span style="color: #4c83ff;">:&gt;=</span> <span style="color: #4c83ff;">:age</span> <span style="color: #4c83ff;">:min_age</span>))

(<span style="color: #FBDE2D;">def</span> <span style="color: #D8FA3C;">match-location</span>
  (clause&gt; <span style="color: #4c83ff;">:=</span> <span style="color: #4c83ff;">:location</span> (<span style="color: #D8FA3C;">t</span><span style="color: #EDEDED; background-color: #000000;">/</span>=&gt; <span style="color: #4c83ff;">:target_location</span> normalize-country)))

(<span style="color: #FBDE2D;">def</span> <span style="color: #D8FA3C;">person-query</span>
  (query&gt;
   {<span style="color: #4c83ff;">:select</span> [<span style="color: #4c83ff;">:*</span>]
    <span style="color: #4c83ff;">:from</span> [<span style="color: #4c83ff;">:users</span>]
    <span style="color: #4c83ff;">:where</span> (and&gt; min-age
                 match-location)}))
</pre>
</div>

<p>
With this, we can start setting normalization functions and other data
handling directly in our queries.
</p>

<p>
One place where this technique will pay off is in testing smaller
snippets. We can break up the subqueries and write specifications for
them using core.spec. That will make it easy to carry out property based
testing with clojure.spec and test.check.
</p>

<p>
Here is one example spec for the min-age query that we've been using:
</p>

<div class="org-src-container">

<pre class="src src-clojure">(<span style="color: #FF6400;">require</span> '[<span style="color: #D8FA3C;">clojure.spec</span> <span style="color: #4c83ff;">:as</span> spec]
         '[<span style="color: #D8FA3C;">clojure.spec.test</span> <span style="color: #4c83ff;">:as</span> test]
         '[<span style="color: #D8FA3C;">taoensso.timbre</span> <span style="color: #4c83ff;">:as</span> log])

(<span style="color: #FBDE2D;">defn</span> <span style="color: #ff1493;">to-int</span> [x]
  (<span style="color: #FBDE2D;">cond</span>
    (int? x) x
    (<span style="color: #FBDE2D;">or</span> (<span style="color: #FF6400;">number?</span> x)
        (<span style="color: #FF6400;">symbol?</span> x)) (<span style="color: #FBDE2D;">try</span>
                       (<span style="color: #FF6400;">int</span> x)
                       (<span style="color: #FBDE2D;">catch</span> <span style="color: #D8FA3C;">Exception</span> ex
                         (<span style="color: #D8FA3C;">log</span><span style="color: #EDEDED; background-color: #000000;">/</span>error (<span style="color: #FF6400;">str</span> <span style="color: #61CE3C;">"to-int Symbol Error: "</span> ex))))
    (<span style="color: #FF6400;">string?</span> x) (<span style="color: #FBDE2D;">try</span>
                  (<span style="color: #D8FA3C;">Integer</span><span style="color: #EDEDED; background-color: #000000;">/</span><span style="color: #919191;">parseInt</span> x)
                  (<span style="color: #FBDE2D;">catch</span> <span style="color: #D8FA3C;">Exception</span> ex
                    (<span style="color: #D8FA3C;">log</span><span style="color: #EDEDED; background-color: #000000;">/</span>error (<span style="color: #FF6400;">str</span> <span style="color: #61CE3C;">"to-int String Error: "</span> ex))))
    <span style="color: #4c83ff;">:default</span>
    <span style="color: #4c83ff;">nil</span>))

(<span style="color: #FBDE2D;">def</span> <span style="color: #D8FA3C;">int&gt;</span>
  (<span style="color: #FF6400;">partial</span> to-int))

(<span style="color: #FBDE2D;">def</span> <span style="color: #D8FA3C;">min-age</span>
  (term&gt; <span style="color: #4c83ff;">:&gt;=</span> <span style="color: #4c83ff;">:age</span> (<span style="color: #D8FA3C;">t</span><span style="color: #EDEDED; background-color: #000000;">/</span>=&gt; <span style="color: #4c83ff;">::min_age</span> int&gt;)))


<span style="color: #8B8989; font-style: italic;">;;; </span><span style="color: #8B8989; font-style: italic;">specs</span>
(<span style="color: #D8FA3C;">spec</span><span style="color: #EDEDED; background-color: #000000;">/</span>fdef to-int
           <span style="color: #4c83ff;">:args</span> (<span style="color: #D8FA3C;">spec</span><span style="color: #EDEDED; background-color: #000000;">/</span>cat <span style="color: #4c83ff;">:x</span> any?)
           <span style="color: #4c83ff;">:ret</span> (<span style="color: #D8FA3C;">spec</span><span style="color: #EDEDED; background-color: #000000;">/</span>nilable int?))

(<span style="color: #D8FA3C;">spec</span><span style="color: #EDEDED; background-color: #000000;">/</span><span style="color: #FBDE2D;">def</span> <span style="color: #4c83ff;">::min_age</span> int?)
(<span style="color: #D8FA3C;">spec</span><span style="color: #EDEDED; background-color: #000000;">/</span><span style="color: #FBDE2D;">def</span> <span style="color: #4c83ff;">::age_check</span>
  (<span style="color: #D8FA3C;">spec</span><span style="color: #EDEDED; background-color: #000000;">/</span><span style="color: #FF6400;">keys</span> <span style="color: #4c83ff;">:req</span> [<span style="color: #4c83ff;">::min_age</span>]))

<span style="color: #8B8989; font-style: italic;">;; </span><span style="color: #8B8989; font-style: italic;">could do </span><span style="color: #4c83ff; font-style: italic;">:junk</span><span style="color: #8B8989; font-style: italic;"> any? and optimize testing through test/instrument</span>
(<span style="color: #D8FA3C;">spec</span><span style="color: #EDEDED; background-color: #000000;">/</span>fdef min-age
           <span style="color: #4c83ff;">:args</span> (<span style="color: #D8FA3C;">spec</span><span style="color: #EDEDED; background-color: #000000;">/</span>alt <span style="color: #4c83ff;">:junk</span> map?
                           <span style="color: #4c83ff;">:match</span> <span style="color: #4c83ff;">::age_check</span>)
           <span style="color: #4c83ff;">:ret</span> (<span style="color: #D8FA3C;">spec</span><span style="color: #EDEDED; background-color: #000000;">/</span>nilable (<span style="color: #D8FA3C;">spec</span><span style="color: #EDEDED; background-color: #000000;">/</span>tuple keyword? keyword? int?)))


<span style="color: #8B8989; font-style: italic;">;; </span><span style="color: #8B8989; font-style: italic;">let 'er rip!!</span>
(<span style="color: #FBDE2D;">-&gt;</span> (<span style="color: #D8FA3C;">test</span><span style="color: #EDEDED; background-color: #000000;">/</span>check [`to-int `min-age])
    (<span style="color: #D8FA3C;">test</span><span style="color: #EDEDED; background-color: #000000;">/</span>summarize-results))
</pre>
</div>

<p>
See how easy it was to write specs for those?
</p>

<p>
These tiny specs can be used for property-based testing which makes
building and maintaining a large test suite much easier.  The computer
will use our spec to write thousands or millions of randomized test
cases which cover much more inputs than we could hope to create by
hand. In the example, the last snippet with <code>test/check</code> was the part
that did testing.
</p>

<p>
(Property-based tests aren't a magic bullet but they do make your test
suite more robust. Since the goal is to get the most extensive test
coverage possible, unit tests will likely still be a helpful complement
to property-based tests. If you're just getting started writing specs,
unit tests can still catch potential spec bugs too.)
</p>

<p>
While we're writing code, we can also turn on
<code>clojure.spec.test/intrument</code> which will try to catch any errors that
come from spec'ed code. Instead of getting a nasty Java stack trace,
clojure.spec yields a targeted error message that describes where the
error took place, why it happened, what the calling function was, etc.
</p>

<p>
If this seems cool, that's because it is! By writing smaller chunks of
code with specs we should be able to get work done faster and have an
easier time debugging any errors that might show up in production.
</p>

<p>
Beyond what I've mentioned, there are other advantages to using
clojure.spec too. For more, check out the <a href="http://blog.cognitect.com/blog/2016/7/26/clojure-spec-screencast-testing">screencasts by Cognitect</a> that
cover how to use clojure.spec.
</p>

<p>
Getting back to the bigger picture of writing SQL queries, we now have
some basic building blocks for SQL conditions. To plan the next few
steps, we'll read through a <a href="http://savage.net.au/SQL/sql-2003-2.bnf.html">BNF grammar for SQL</a> and the <a href="http://blog.cognitect.com/blog/2016/7/13/screencast-spec-leverage">Honey SQL
implementation</a> (OK maybe we'll skip the BNF). My goal is to
build this abstraction over Honey SQL's map DSL. By building on top of
an existing library I should be able to save time not re-inventing the
SQL DSL wheel and profit from future improvements that Honey SQL makes.
</p>

<p>
The easiest place to start is by writing a whole function that wraps SQL
queries. We want the whole query to be a transitive so that any nil
values from the map are filtered out before running the query. This can
be done by just interning the <code>transitive</code> function from the deepfns
library.
</p>

<div class="org-src-container">

<pre class="src src-clojure">(<span style="color: #FBDE2D;">def</span> <span style="color: #D8FA3C;">query&gt;</span>
  <span style="color: #61CE3C;">"Takes a transitive `</span><span style="color: #61CE3C;">f</span><span style="color: #61CE3C;">` and uses that to walk a datastructure.</span>
<span style="color: #61CE3C;">  Returns a SQL query formatted for Honey SQL."</span>
  <span style="color: #D8FA3C;">deep</span><span style="color: #EDEDED; background-color: #000000;">/</span>transitive)
</pre>
</div>

<p>
Here is an example SQL query from the Honey SQL README that shows many
query options.
</p>

<div class="org-src-container">

<pre class="src src-clojure">{<span style="color: #4c83ff;">:select</span> [<span style="color: #4c83ff;">:f.*</span> <span style="color: #4c83ff;">:b.baz</span> <span style="color: #4c83ff;">:c.quux</span> [<span style="color: #4c83ff;">:b.bla</span> <span style="color: #61CE3C;">"bla-bla"</span>]
          (<span style="color: #D8FA3C;">sql</span><span style="color: #EDEDED; background-color: #000000;">/</span>call <span style="color: #4c83ff;">:now</span>) (<span style="color: #D8FA3C;">sql</span><span style="color: #EDEDED; background-color: #000000;">/</span>raw <span style="color: #61CE3C;">"@x </span><span style="color: #4c83ff;">:=</span><span style="color: #61CE3C;"> 10"</span>)]
 <span style="color: #4c83ff;">:modifiers</span> [<span style="color: #4c83ff;">:distinct</span>]
 <span style="color: #4c83ff;">:from</span> [[<span style="color: #4c83ff;">:foo</span> <span style="color: #4c83ff;">:f</span>] [<span style="color: #4c83ff;">:baz</span> <span style="color: #4c83ff;">:b</span>]]
 <span style="color: #4c83ff;">:join</span> [<span style="color: #4c83ff;">:draq</span> [<span style="color: #4c83ff;">:=</span> <span style="color: #4c83ff;">:f.b</span> <span style="color: #4c83ff;">:draq.x</span>]]
 <span style="color: #4c83ff;">:left-join</span> [[<span style="color: #4c83ff;">:clod</span> <span style="color: #4c83ff;">:c</span>] [<span style="color: #4c83ff;">:=</span> <span style="color: #4c83ff;">:f.a</span> <span style="color: #4c83ff;">:c.d</span>]]
 <span style="color: #4c83ff;">:right-join</span> [<span style="color: #4c83ff;">:bock</span> [<span style="color: #4c83ff;">:=</span> <span style="color: #4c83ff;">:bock.z</span> <span style="color: #4c83ff;">:c.e</span>]]
 <span style="color: #4c83ff;">:where</span> [<span style="color: #4c83ff;">:or</span>
         [<span style="color: #4c83ff;">:and</span> [<span style="color: #4c83ff;">:=</span> <span style="color: #4c83ff;">:f.a</span> <span style="color: #61CE3C;">"bort"</span>] [<span style="color: #4c83ff;">:not=</span> <span style="color: #4c83ff;">:b.baz</span> (<span style="color: #D8FA3C;">sql</span><span style="color: #EDEDED; background-color: #000000;">/</span>param <span style="color: #4c83ff;">:param1</span>)]]
         [<span style="color: #4c83ff;">:&lt;</span> 1 2 3]
         [<span style="color: #4c83ff;">:in</span> <span style="color: #4c83ff;">:f.e</span> [1 (<span style="color: #D8FA3C;">sql</span><span style="color: #EDEDED; background-color: #000000;">/</span>param <span style="color: #4c83ff;">:param2</span>) 3]]
         [<span style="color: #4c83ff;">:between</span> <span style="color: #4c83ff;">:f.e</span> 10 20]]
 <span style="color: #4c83ff;">:group-by</span> [<span style="color: #4c83ff;">:f.a</span>]
 <span style="color: #4c83ff;">:having</span> [<span style="color: #4c83ff;">:&lt;</span> 0 <span style="color: #4c83ff;">:f.e</span>]
 <span style="color: #4c83ff;">:order-by</span> [[<span style="color: #4c83ff;">:b.baz</span> <span style="color: #4c83ff;">:desc</span>] <span style="color: #4c83ff;">:c.quux</span> [<span style="color: #4c83ff;">:f.a</span> <span style="color: #4c83ff;">:nulls-first</span>]]
 <span style="color: #4c83ff;">:limit</span> 50
 <span style="color: #4c83ff;">:offset</span> 10}
</pre>
</div>

<p>
Let's take the easy parts first. We could change the bottom sections
where the limit, offset, etc. is hard-coded into the query. Doing this
gives the query more flexibility.
</p>

<div class="org-src-container">

<pre class="src src-clojure">{<span style="color: #8B8989; font-style: italic;">;; </span><span style="color: #8B8989; font-style: italic;">f.a groups by default</span>
 <span style="color: #8B8989; font-style: italic;">;; </span><span style="color: #8B8989; font-style: italic;">giving a map with group-by will override f.a</span>
 <span style="color: #4c83ff;">:group-by</span> (<span style="color: #D8FA3C;">t</span><span style="color: #EDEDED; background-color: #000000;">/</span><span style="color: #FBDE2D;">default&gt;</span> <span style="color: #4c83ff;">:f.a</span> <span style="color: #4c83ff;">:group-by</span>)
 <span style="color: #8B8989; font-style: italic;">;; </span><span style="color: #8B8989; font-style: italic;">0 by default</span>
 <span style="color: #8B8989; font-style: italic;">;; </span><span style="color: #8B8989; font-style: italic;">a map with </span><span style="color: #4c83ff; font-style: italic;">:having</span><span style="color: #8B8989; font-style: italic;"> can change it from 0</span>
 <span style="color: #4c83ff;">:having</span> (term&gt; <span style="color: #4c83ff;">:&gt;</span> <span style="color: #4c83ff;">:f.e</span> (<span style="color: #D8FA3C;">t</span><span style="color: #EDEDED; background-color: #000000;">/</span><span style="color: #FBDE2D;">default&gt;</span> <span style="color: #ff1493;">0</span> <span style="color: #4c83ff;">:having</span>))
 <span style="color: #8B8989; font-style: italic;">;; </span><span style="color: #8B8989; font-style: italic;">use this default clause for order-by</span>
 <span style="color: #4c83ff;">:order-by</span> (<span style="color: #D8FA3C;">t</span><span style="color: #EDEDED; background-color: #000000;">/</span><span style="color: #FBDE2D;">default&gt;</span>
            [[<span style="color: #4c83ff;">:b.baz</span> <span style="color: #4c83ff;">:desc</span>] <span style="color: #4c83ff;">:c.quux</span> [<span style="color: #4c83ff;">:f.a</span> <span style="color: #4c83ff;">:nulls-first</span>]]
            <span style="color: #4c83ff;">:order-by</span>)
 <span style="color: #8B8989; font-style: italic;">;; </span><span style="color: #8B8989; font-style: italic;">default to 50 or 10 unless overriden</span>
 <span style="color: #4c83ff;">:limit</span> (<span style="color: #D8FA3C;">t</span><span style="color: #EDEDED; background-color: #000000;">/</span><span style="color: #FBDE2D;">default&gt;</span> <span style="color: #ff1493;">50</span> <span style="color: #4c83ff;">:limit</span>)
 <span style="color: #4c83ff;">:offset</span> (<span style="color: #D8FA3C;">t</span><span style="color: #EDEDED; background-color: #000000;">/</span><span style="color: #FBDE2D;">default&gt;</span> <span style="color: #ff1493;">10</span> <span style="color: #4c83ff;">:offset</span>)}
</pre>
</div>

<p>
The query now has default values for lots of parameters. If we ever need
to override them, we could easily change the default value. Compare that
to if the query was static or required us to have multiple snippets with
hard coded values.
</p>

<p>
The select clause is a bit trickier. When we turn this Clojure map into
a transitive, keywords in Honey SQL's vector's will be deleted. Here's
an example of the issue:
</p>

<div class="org-src-container">

<pre class="src src-clojure">(<span style="color: #FF6400;">require</span> '[<span style="color: #D8FA3C;">honeysql.core</span> <span style="color: #4c83ff;">:as</span> sql])

<span style="color: #8B8989; font-style: italic;">;; </span><span style="color: #8B8989; font-style: italic;">our target output, default Honey SQL</span>
(<span style="color: #D8FA3C;">sql</span><span style="color: #EDEDED; background-color: #000000;">/</span><span style="color: #FF6400;">format</span>
 {<span style="color: #4c83ff;">:select</span> [<span style="color: #4c83ff;">:f.*</span> <span style="color: #4c83ff;">:b.baz</span> <span style="color: #4c83ff;">:c.quux</span> [<span style="color: #4c83ff;">:b.bla</span> <span style="color: #61CE3C;">"bla-bla"</span>]
           (<span style="color: #D8FA3C;">sql</span><span style="color: #EDEDED; background-color: #000000;">/</span>call <span style="color: #4c83ff;">:now</span>) (<span style="color: #D8FA3C;">sql</span><span style="color: #EDEDED; background-color: #000000;">/</span>raw <span style="color: #61CE3C;">"@x </span><span style="color: #4c83ff;">:=</span><span style="color: #61CE3C;"> 10"</span>)]})
<span style="color: #8B8989; font-style: italic;">;;</span><span style="color: #8B8989; font-style: italic;">=&gt; ["SELECT f.*, b.baz, c.quux, b.bla AS bla_bla, now(), @x </span><span style="color: #4c83ff; font-style: italic;">:=</span><span style="color: #8B8989; font-style: italic;"> 10"]</span>


<span style="color: #8B8989; font-style: italic;">;; </span><span style="color: #8B8989; font-style: italic;">our output, abstraction disaster!</span>
(<span style="color: #FBDE2D;">-&gt;</span> ((query&gt;
      {<span style="color: #4c83ff;">:select</span> [<span style="color: #4c83ff;">:f.*</span> <span style="color: #4c83ff;">:b.baz</span> <span style="color: #4c83ff;">:c.quux</span> [<span style="color: #4c83ff;">:b.bla</span> <span style="color: #61CE3C;">"bla-bla"</span>]
                (<span style="color: #D8FA3C;">sql</span><span style="color: #EDEDED; background-color: #000000;">/</span>call <span style="color: #4c83ff;">:now</span>) (<span style="color: #D8FA3C;">sql</span><span style="color: #EDEDED; background-color: #000000;">/</span>raw <span style="color: #61CE3C;">"@x </span><span style="color: #4c83ff;">:=</span><span style="color: #61CE3C;"> 10"</span>)]})
     {})
    <span style="color: #D8FA3C;">sql</span><span style="color: #EDEDED; background-color: #000000;">/</span>format)
<span style="color: #8B8989; font-style: italic;">;;</span><span style="color: #8B8989; font-style: italic;">=&gt; ["SELECT ? AS NULL, ()" "bla-bla"]</span>
</pre>
</div>

<p>
The transitives use the keyword filled vectors for lookups. If there's a
map of keywords in the input, then the keywords will be replaced by the
value of the map.
</p>

<div class="org-src-container">

<pre class="src src-clojure"><span style="color: #8B8989; font-style: italic;">;; </span><span style="color: #8B8989; font-style: italic;">we want to keep both keywords here</span>
<span style="color: #8B8989; font-style: italic;">;; </span><span style="color: #8B8989; font-style: italic;">they </span><span style="color: #4c83ff; font-style: italic;">:bar</span><span style="color: #8B8989; font-style: italic;"> gets deleted though since the input has no </span><span style="color: #4c83ff; font-style: italic;">:bar</span>
((query&gt; [<span style="color: #4c83ff;">:foo</span> <span style="color: #4c83ff;">:bar</span>])
 {<span style="color: #4c83ff;">:foo</span> 1})
<span style="color: #8B8989; font-style: italic;">;;</span><span style="color: #8B8989; font-style: italic;">=&gt; [1]</span>
</pre>
</div>

<p>
This is a bummer for our SQL DSL since all of those SQL commands get
removed when the transitive runs. We have a couple options for fixing
this:
</p>

<ol class="org-ol">
<li>Write a new function that saves keywords
</li>
<li>Change the transitive abstraction
</li>
<li>Pick a new SQL DSL
</li>
<li>Add a special SQL fn-handler to Honey SQL
</li>
</ol>

<p>
Option one is what I'm going to stick with.
</p>

<p>
Inside a transitive code can be escaped using <code>constantly</code>. For what
we're working on we need a way to escape some keywords while
still evaluating transitives. Ideally, we should do this without making
developers write <code>constantly</code> everywhere to escape things too.
</p>

<p>
The easiest way is to just change the transitive abstraction. If we keep
it from evaluating keywords then all SQL keywords we stay in our
output. This new behavior should go in <code>query&gt;</code>. Any nested lookups we
still want to do can be wrapped in a function like <code>=&gt;</code> or another
<code>query&gt;</code>.
</p>

<div class="org-src-container">

<pre class="src src-clojure"><span style="color: #8B8989; font-style: italic;">;; </span><span style="color: #8B8989; font-style: italic;">goal</span>
<span style="color: #8B8989; font-style: italic;">;;</span><span style="color: #8B8989; font-style: italic;">=&gt; ["SELECT f.*, b.baz, c.quux, b.bla AS bla_bla, now(), @x </span><span style="color: #4c83ff; font-style: italic;">:=</span><span style="color: #8B8989; font-style: italic;"> 10"]</span>

(<span style="color: #FBDE2D;">-&gt;</span> ((query&gt;
      {<span style="color: #4c83ff;">:select</span> [<span style="color: #4c83ff;">:f.*</span> <span style="color: #4c83ff;">:b.baz</span> <span style="color: #4c83ff;">:c.quux</span> [<span style="color: #4c83ff;">:b.bla</span> <span style="color: #61CE3C;">"bla-bla"</span>]
                (<span style="color: #D8FA3C;">sql</span><span style="color: #EDEDED; background-color: #000000;">/</span>call <span style="color: #4c83ff;">:now</span>) (<span style="color: #D8FA3C;">sql</span><span style="color: #EDEDED; background-color: #000000;">/</span>raw <span style="color: #61CE3C;">"@x </span><span style="color: #4c83ff;">:=</span><span style="color: #61CE3C;"> 10"</span>)]})
     {})
    <span style="color: #D8FA3C;">sql</span><span style="color: #EDEDED; background-color: #000000;">/</span>format)
<span style="color: #8B8989; font-style: italic;">;;</span><span style="color: #8B8989; font-style: italic;">=&gt; ["SELECT f.*, b.baz, c.quux, b.bla AS bla_bla, (), ()"]</span>
</pre>
</div>

<p>
Great! Now there's one major thing left to fix. The calls to
<code>honeysql.core</code> get evaluated during the transitive's expansion. Normally
those calls are supposed to be left in the map that we give to
<code>honeysql.core/format</code>.
</p>

<p>
So we need a way to stash those Honey SQL calls so they can be expanded
later.
</p>

<div class="org-src-container">

<pre class="src src-clojure">(<span style="color: #FBDE2D;">defn</span> <span style="color: #ff1493;">call</span>
  <span style="color: #61CE3C;">"Represents a SQL function call. Name should be a keyword."</span>
  ([name]
   (<span style="color: #FF6400;">constantly</span> (<span style="color: #D8FA3C;">sql</span><span style="color: #EDEDED; background-color: #000000;">/</span>call name)))
  ([name &amp; args]
   (<span style="color: #FF6400;">constantly</span> (<span style="color: #FF6400;">apply</span> <span style="color: #D8FA3C;">sql</span><span style="color: #EDEDED; background-color: #000000;">/</span>call name args))))

(<span style="color: #FBDE2D;">defn</span> <span style="color: #ff1493;">raw</span> [s]
  <span style="color: #61CE3C;">"Represents a raw SQL string"</span>
  (<span style="color: #FF6400;">constantly</span> (<span style="color: #D8FA3C;">sql</span><span style="color: #EDEDED; background-color: #000000;">/</span>raw s)))

(<span style="color: #FBDE2D;">defn</span> <span style="color: #ff1493;">param</span> [name]
  <span style="color: #61CE3C;">"Represents a SQL parameter which can be filled in later"</span>
  (<span style="color: #FF6400;">constantly</span> (<span style="color: #D8FA3C;">sql</span><span style="color: #EDEDED; background-color: #000000;">/</span>param name)))
</pre>
</div>

<p>
This works well enough. Now the output should be the same. Let's check:
</p>

<div class="org-src-container">

<pre class="src src-clojure"><span style="color: #8B8989; font-style: italic;">;; </span><span style="color: #8B8989; font-style: italic;">goal</span>
<span style="color: #8B8989; font-style: italic;">;;</span><span style="color: #8B8989; font-style: italic;">=&gt; ["SELECT f.*, b.baz, c.quux, b.bla AS bla_bla, now(), @x </span><span style="color: #4c83ff; font-style: italic;">:=</span><span style="color: #8B8989; font-style: italic;"> 10"]</span>

(<span style="color: #D8FA3C;">sql</span><span style="color: #EDEDED; background-color: #000000;">/</span><span style="color: #FF6400;">format</span>
 ((query&gt; {<span style="color: #4c83ff;">:select</span> [<span style="color: #4c83ff;">:f.*</span> <span style="color: #4c83ff;">:b.baz</span> <span style="color: #4c83ff;">:c.quux</span> [<span style="color: #4c83ff;">:b.bla</span> <span style="color: #61CE3C;">"bla-bla"</span>]
                    (call <span style="color: #4c83ff;">:now</span>)
                    (raw <span style="color: #61CE3C;">"@x </span><span style="color: #4c83ff;">:=</span><span style="color: #61CE3C;"> 10"</span>)]})
  {}))
<span style="color: #8B8989; font-style: italic;">;;</span><span style="color: #8B8989; font-style: italic;">=&gt; ["SELECT f.*, b.baz, c.quux, b.bla AS bla_bla, now(), @x </span><span style="color: #4c83ff; font-style: italic;">:=</span><span style="color: #8B8989; font-style: italic;"> 10"]</span>
</pre>
</div>

<p>
Vundabar! Those Honey SQL calls are finally working. We should now have
all the pieces in place for translating that large SQL query into our
transitive abstraction.
</p>

<div class="org-src-container">

<pre class="src src-clojure">(query&gt;
   {<span style="color: #4c83ff;">:select</span> [<span style="color: #4c83ff;">:f.*</span> <span style="color: #4c83ff;">:b.baz</span> <span style="color: #4c83ff;">:c.quux</span> [<span style="color: #4c83ff;">:b.bla</span> <span style="color: #61CE3C;">"bla-bla"</span>]
             (call <span style="color: #4c83ff;">:now</span>) (raw <span style="color: #61CE3C;">"@x </span><span style="color: #4c83ff;">:=</span><span style="color: #61CE3C;"> 10"</span>)]
    <span style="color: #4c83ff;">:modifiers</span> [<span style="color: #4c83ff;">:distinct</span>]
    <span style="color: #4c83ff;">:from</span> [[<span style="color: #4c83ff;">:foo</span> <span style="color: #4c83ff;">:f</span>] [<span style="color: #4c83ff;">:baz</span> <span style="color: #4c83ff;">:b</span>]]
    <span style="color: #4c83ff;">:join</span> [<span style="color: #4c83ff;">:draq</span> [<span style="color: #4c83ff;">:=</span> <span style="color: #4c83ff;">:f.b</span> <span style="color: #4c83ff;">:draq.x</span>]]
    <span style="color: #4c83ff;">:left-join</span> [[<span style="color: #4c83ff;">:clod</span> <span style="color: #4c83ff;">:c</span>] [<span style="color: #4c83ff;">:=</span> <span style="color: #4c83ff;">:f.a</span> <span style="color: #4c83ff;">:c.d</span>]]
    <span style="color: #4c83ff;">:right-join</span> [<span style="color: #4c83ff;">:bock</span> [<span style="color: #4c83ff;">:=</span> <span style="color: #4c83ff;">:bock.z</span> <span style="color: #4c83ff;">:c.e</span>]]
    <span style="color: #4c83ff;">:where</span> [<span style="color: #4c83ff;">:or</span>
            [<span style="color: #4c83ff;">:and</span>
             [<span style="color: #4c83ff;">:=</span> <span style="color: #4c83ff;">:f.a</span> <span style="color: #61CE3C;">"bort"</span>]
             <span style="color: #8B8989; font-style: italic;">;; </span><span style="color: #8B8989; font-style: italic;">pass in param1 or this will be nil</span>
             (term&gt; <span style="color: #4c83ff;">:not=</span> <span style="color: #4c83ff;">:b.baz</span> (<span style="color: #D8FA3C;">t</span><span style="color: #EDEDED; background-color: #000000;">/</span>=&gt; <span style="color: #4c83ff;">:param1</span>))]
            [<span style="color: #4c83ff;">:&lt;</span> 1 2 3]
            [<span style="color: #4c83ff;">:in</span> <span style="color: #4c83ff;">:f.e</span> [1 (<span style="color: #D8FA3C;">t</span><span style="color: #EDEDED; background-color: #000000;">/</span>=&gt; <span style="color: #4c83ff;">:param2</span>) 3]]
            [<span style="color: #4c83ff;">:between</span> <span style="color: #4c83ff;">:f.e</span> 10 20]]
    <span style="color: #8B8989; font-style: italic;">;; </span><span style="color: #4c83ff; font-style: italic;">:f.a</span><span style="color: #8B8989; font-style: italic;"> groups by default</span>
    <span style="color: #4c83ff;">:group-by</span> (<span style="color: #D8FA3C;">t</span><span style="color: #EDEDED; background-color: #000000;">/</span><span style="color: #FBDE2D;">default&gt;</span> [<span style="color: #4c83ff;">:f.a</span>] <span style="color: #4c83ff;">:group-by</span>)
    <span style="color: #8B8989; font-style: italic;">;; </span><span style="color: #8B8989; font-style: italic;">0 by default</span>
    <span style="color: #4c83ff;">:having</span> (term&gt; <span style="color: #4c83ff;">:&lt;</span> <span style="color: #4c83ff;">:f.e</span> (<span style="color: #D8FA3C;">t</span><span style="color: #EDEDED; background-color: #000000;">/</span><span style="color: #FBDE2D;">default&gt;</span> <span style="color: #ff1493;">0</span> <span style="color: #4c83ff;">:having</span>))
    <span style="color: #8B8989; font-style: italic;">;; </span><span style="color: #8B8989; font-style: italic;">use this default clause for order-by</span>
    <span style="color: #4c83ff;">:order-by</span> (<span style="color: #D8FA3C;">t</span><span style="color: #EDEDED; background-color: #000000;">/</span><span style="color: #FBDE2D;">default&gt;</span>
               [[<span style="color: #4c83ff;">:b.baz</span> <span style="color: #4c83ff;">:desc</span>] <span style="color: #4c83ff;">:c.quux</span> [<span style="color: #4c83ff;">:f.a</span> <span style="color: #4c83ff;">:nulls-first</span>]]
               <span style="color: #4c83ff;">:order-by</span>)
    <span style="color: #8B8989; font-style: italic;">;; </span><span style="color: #8B8989; font-style: italic;">default to 50 or 10 unless overriden</span>
    <span style="color: #4c83ff;">:limit</span> (<span style="color: #D8FA3C;">t</span><span style="color: #EDEDED; background-color: #000000;">/</span><span style="color: #FBDE2D;">default&gt;</span> <span style="color: #ff1493;">50</span> <span style="color: #4c83ff;">:limit</span>)
    <span style="color: #4c83ff;">:offset</span> (<span style="color: #D8FA3C;">t</span><span style="color: #EDEDED; background-color: #000000;">/</span><span style="color: #FBDE2D;">default&gt;</span> <span style="color: #ff1493;">10</span> <span style="color: #4c83ff;">:offset</span>)})
</pre>
</div>

<p>
Yup, this outputs the same SQL code as Honey SQL does. Mission
accomplished.
</p>

<p>
Now that we have a basic tool working. Let's lay out the pros and cons.
</p>

<p>
advantages:
</p>
<ul class="org-ul">
<li>Developer Friendly: Easier to test small chunks as you develop, giant
queries can be a pain to test all at once. It's more effective to test
the large query after you know that the smaller queries already work.
</li>
<li>DRY: Some chunks will be common to many queries, why dump them all
over your app? We do this with code, why not with database queries?
</li>
<li>Easier Maintenance: Update small chunks that you know work and are
used by larger queries, don't waste your time digging through giant
queries.
</li>
<li>Functional Pipelining: In each query chunk we can apply functions to
the data that we're passed. Normalization details can be embedded as
functions in our queries.
</li>
<li>Functional Queries: Queries can be built up from the data that we're
given. We can put declarative control structures into our code that
will add or subtract query sections, based on the data they're
passed.
</li>
</ul>

<p>
disadvantages:
</p>
<ul class="org-ul">
<li>learning curve
</li>
<li>it's an abstraction so it could be harder to optimize the output (not
a problem for Elasticsearch)
</li>
<li>Honey SQL might cover only a subset of SQL that you want to use
</li>
</ul>

<p>
Last week Rich Hickey laid out the pattern of immutable code in his
<a href="https://www.youtube.com/watch?v=oyLBGkS5ICk">spec-ulation keynote</a>. While his focus was on dependencies and web APIs,
I think the some of the idea carries over to database queries too.
</p>

<p>
When we change the APIs of our system, there is a good chance that we'll
need to change the database queries as well. The queries won't have as
much exposure to the outside world as something like a REST API but they
may need minor updates. We might also need to have multiple queries
running to support different versions of an API.
</p>

<p>
Normally supporting slightly different queries would require&#x2026; well,
writing separate queries. There may also be breaking changes between the
queries and, eventually, a service could be deprecated to make room for
the new code. Through careful use of transitives, however, we should be
able to build multiple queries out of one transitive and avoid breaking
changes.
</p>

<p>
Instead of worrying about needing to write a new query for feature X,
we may be able to just tweak the existing query and be done. Old queries
can be deleted if they're unused but there shouldn't be an impetus to do
so because we changed versions. If people still consume a stable but
deprecated version of a service, they should be able to continue doing
so into the future.
</p>

<p>
With transitives, you're now free to add new clauses, fields,
normalization, and transformations to your queries. Without much effort
you should be able to build queries that support both the current and
deprecated APIs at the same time.
</p>

<p>
The first version of this library is now ready to go (it's up <a href="https://github.com/greenyouse/dorali">here</a> on
GitHub). The end result is a pithy amount of code compared to what
I thought would be required. One of my goals was to keep the core
library small but extensible, so I'm glad that this worked out. This is
more of a general design pattern to follow and extend than a feature
complete, standard library.
</p>

<p>
This was a long and fairly dense post. The concept of transitives
and how to use them, however, is a little mind bending, so I would argue
that the space was warranted. This still isn't a full display of their
usefulness but I hope it was interesting enough for you to spin up a
REPL and try it out.
</p>


<br>

<div id="disqus_thread"></div> <script> var disqus_config = function () { this.page.url = "https://edbabcock.com"; this.page.identifier = "composable-queries"; }; (function() { var d = document, s = d.createElement('script'); s.src = '//edbabcock-com.disqus.com/embed.js'; s.setAttribute('data-timestamp', +new Date()); (d.head || d.body).appendChild(s); })(); </script> <noscript>It would be better if comments didn't need JS. Turn JavaScript on to see the comments. <a href="https://disqus.com/?ref_noscript">Comments powered by Disqus.</a></noscript>

<br>
</div></div></div>
</div>
<div id="postamble" class="status">
<footer> <hr />
                         <p><a href='http://creativecommons.org/licenses/by-nc-sa/3.0/' target='_blank'>Â©copyright 2015</a>, by <a href='/about.html'>Ed Babcock</a> (^_^)v</p>
                         </footer>
                         <script type='text/javascript' src='js/jquery.min.js'></script>
                         <script type='text/javascript' src='js/bootstrap.min.js'></script>
</div>
</body>
</html>
